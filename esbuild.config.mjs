import builtins from "builtin-modules";
import { Command } from "commander";
import dotenv from "dotenv";
import esbuild from "esbuild";
import * as fs from "fs";
import * as path from "path";
import manifest from "./manifest.json" with { type: "json" };
import packageJson from "./package.json" with { type: "json" };

dotenv.config({ path: [".env"], quiet: true });

const program = new Command();
program
	.option("-p, --production", "Production build")
	.option("-v, --vault [vault]", "Use vault path", false)
	.option("-o, --output-dir <path>", "Output path")
	.option("-b, --beta", "Pre-release version")
	.parse();

const options = program.opts();
const isProd = !!options.production;
const isBeta = !!options.beta;
const isStyled = fs.existsSync("src/styles.css");
const pluginID = manifest.id;

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin: ${packageJson.repository}
*/`;

function resolveOutputDir() {
	if (options.outputDir) return options.outputDir;

	if (options.vault) {
		const vaultPath =
			typeof options.vault === "string" ? options.vault : process.env.VAULT;

		if (!vaultPath) throw new Error("VAULT environment variable not set");

		const folderPath = path.join(vaultPath, ".obsidian", "plugins", pluginID);
		if (!fs.existsSync(folderPath)) fs.mkdirSync(folderPath, { recursive: true });

		if (!isProd) fs.writeFileSync(path.join(folderPath, ".hotreload"), "");

		return folderPath;
	}

	return isProd ? "./dist" : "./";
}

function prepareOutputDir(dir) {
	if ((isProd || options.outputDir) && fs.existsSync(dir)) {
		fs.rmSync(dir, { recursive: true });
	}

	if (isBeta && !fs.existsSync("manifest-beta.json")) {
		fs.copyFileSync("manifest.json", "manifest-beta.json");
	}
}

function getPlugins(outDir) {
	const plugins = [];
	if (isStyled) {
		plugins.push({
			name: "move-styles",
			setup(build) {
				build.onEnd(() => {
					fs.copyFileSync("src/styles.css", path.join(outDir, "styles.css"));
				});
			},
		});
	}

	plugins.push({
		name: "copy-manifest",
		setup(build) {
			build.onEnd(() => {
				const manifestSource = isBeta ? "manifest-beta.json" : "manifest.json";
				fs.copyFileSync(manifestSource, path.join(outDir, "manifest.json"));
			});
		},
	});
	plugins.push({
		name: "remove-console-debug",
		setup(build) {
			if (!isProd) return;
			const consoleDebugRegex = /console\.(debug|warn)\(.*?\);?/gs;

			build.onLoad({ filter: /\.(ts|js|tsx|jsx)$/ }, async (args) => {
				const fs = await import("fs/promises");
				const source = await fs.readFile(args.path, "utf8");
				const cleaned = source.replace(consoleDebugRegex, "");
				return { contents: cleaned, loader: args.path.endsWith(".ts") ? "ts" : "js" };
			});
		},
	});

	return plugins;
}

async function buildPlugin() {
	const outDir = resolveOutputDir();
	prepareOutputDir(outDir);

	const entryPoints = ["src/main.ts"];
	if (isStyled) entryPoints.push("src/styles.css");
	const context = await esbuild.context({
		banner: { js: banner },
		entryPoints,
		bundle: true,
		external: [
			"obsidian",
			"electron",
			"@codemirror/autocomplete",
			"@codemirror/collab",
			"@codemirror/commands",
			"@codemirror/language",
			"@codemirror/lint",
			"@codemirror/search",
			"@codemirror/state",
			"@codemirror/view",
			"@lezer/common",
			"@lezer/highlight",
			"@lezer/lr",
			...builtins,
		],
		format: "cjs",
		target: "esnext",
		logLevel: "info",
		sourcemap: isProd ? false : "inline",
		treeShaking: true,
		minify: isProd,
		minifySyntax: isProd,
		minifyWhitespace: isProd,
		outdir: outDir,
		plugins: getPlugins(outDir),
	});

	console.log(`ðŸš€ ${isProd ? "Production" : "Development"} build`);
	console.log(`ðŸ“¤ Output directory: ${outDir}`);

	if (isProd) {
		await context.rebuild();
		console.log("âœ… Build successful");
		process.exit(0);
	} else {
		await context.watch();
	}
}

buildPlugin().catch((err) => {
	console.error("Build failed:", err);
	process.exit(1);
});
